## HTML/CSS

**HTML 和 HTML5 区别**

1. 文档的类型声明不同
2. H5 新增了结构化的语义标签，以及新增了许多标签和表单属性
3. H5 新增 canvas 绘图功能，以及新增了像浏览器存储、地图定位、文件对象、多媒体等新的 API

**CSS3 新特性**

* 新增结构选择器 ( 如: first-child、last-child、nth-child )

* 新增 @font-face 特性，使得客户端能够加载服务端的字体文件

  ```css
  @font-face {
      font-family:xxx;
      src:url(xxx.eot);
  }
  ```

* 盒模型新增 border-radius、box-shadow 、渐变效果

* 新增 transition(过渡) 和 animation(动画)

* 新增 flex 布局、grid 网格布局、媒体查询 @media screen



## Javascript

**javascript 类型转换**



### 作用域和闭包

**什么是作用域**

1. 作用域是变量或者函数起作用的一个区域，这个区域存放着各种变量和函数，作用域规定了如何根据变量名进行变量查找。

2. 在 ES6 之前，只有函数作用域和全局作用域。全局作用域只有一个，函数作用域肯定在全局作用域里，而函数作用域还可以继续嵌套函数作用域

**作用域链**

	从最底层的函数作用域到全局作用域的嵌套，就形成了一条作用域链。

**作用域中变量的查找规则**

	先从当前作用域中查找，如果没有再到父级作用域查找，如果在全局作用域还没有找到的话，就会报错( xxx 			is not definded，非严格模式下还会在全局自动创建这个变量)

**词法作用域**

	词法作用域也叫静态作用域，指的是函数在定义他们的作用域里运行。词法作用域在代码书写的时候就确定了。（注：js 只有静态作用域）

```
注意：
1. 动态作用域指的是函数执行时的作用域根据他们的执行环境和调用者而改变
2. eval()和with可以通过其特殊性用来“欺骗”词法作用域，不过正常情况下都不建议使用
```

**块级作用域**



**闭包的作用和原理**

* **什么是闭包：**



**防抖与节流**



**javascript 事件循环**



**javascript 垃圾回收机制**

* **为何需要垃圾回收机制？**

  javascript每次创建变量的时候都需要消耗内存来存储变量，而这些内存最终都必须要被释放使得他们能够被再用，如果这些内存都不被释放，则占用完系统中的内存之后就会造成系统的崩溃。因此就需要有垃圾回收机制来找出不参与运行的变量并释放其内存空间。

  ```
  垃圾回收操作开销较大，因此会按照固定时间间隔周期性地执行
  ```

* **如何垃圾回收？**

  垃圾回收就是找到不再使用的变量，然后释放掉其占用的内存。如何确定一个变量是否不再被使用？

  目前主流的浏览器通常采用两种方法来确定一个变量是否不再被使用：标记清除法、引用计数法

  1. **标记清除法(常见)**：

     当 javascript 变量进入环境时，就标记这个变量为'进入环境'，进入环境中的变量是不能释放的。当变量离开环境时，则给其标记’离开环境‘

     垃圾收集器一开始会先给内存中所有的变量都加上标记，然后再去掉进入环境中的变量的标记还有被环境中的变量引用的标记。在此基础上，被标记的变量就被视为准备删除的变量并销毁，回收他们占用的内存。

  2. **引用计数法(少见，低版本 IE 使用) ：**

     引用计数法就是跟踪记录每个变量被引用的次数，当我们讲一个引用类型复制给一个变量时，这个变量的引用次数就 + 1，当这个变量指向其他值时这个变量的引用数就 -1，当这个变量的引用数为 0 时，就会被回收。这种方式有个弊端就是他**不能解决循环引用的问题**，如果一个变量被循环引用就没办法被清除，就会造成内存泄漏。

     ```
     // 循环引用示例，这里 example 函数调用完后，a，b 变量的引用计数都是 2，他们永远不会被释放
     function example() { 
         var a = {};
         var b = {};
         a.val = b;
         b.val = a;
     }
     ```


**Ajax 步骤**



**this 指向分为几种情况**



**javascript 事件流，IE 中的事件流**







### ES6

**词法作用域和块级作用域**



## 网络相关

**http 请求方式有哪些**



**get 和 post 的区别**

1. post 更安全

2. get 请求是幂等的，post 是非幂等的

   ```
   幂等和非幂等
   ```

3. 在回退的时候 get 不会重复发送请求，而post 会重新发送请求
4. 



**post 请求获取值**



**数据量大如何发送请求**



**HTTP 与 HTTPS 的区别**



**HTTP1.0 跟 1.1的区别**

HTTP 1.0 时请求一次完毕后就断开连接，HTTP 1.1 实现了长链接



**HTTP 1.0 跟 2.0 的区别**

1. 1.0 是字节传输，2.0 为二进制传输，效率更高
2. 2.0 对头部有压缩，减少流量消耗
3. 2.0 服务端可以主动推送资源给客户端



**TCP 拥塞控制，流量控制**



**前端跨域的几种方式及实现**



**跨域携带 cookie**



**http 状态码意义**



## 框架相关

### Vue 相关

**Vue 生命周期**



**jQuery 和 Vue 的区别**



### 小程序相关

**小程序 setData 原理**



**小程序获取用户数据，手机号**



**小程序 1rpx 问题**



**小程序优化**



**小程序上拉刷新和下拉加载需要注意的事**



**小程序和 Vue 的区别，两者的优缺点**



**小程序路由**





### jQuery 相关

**jquery 中绑定事件的方法**



### Boostrap 相关

**boostrap 响应式实现**



**响应式的实现方式有哪几种**



## 工程化相关

### webpack

**base64 图片格式的缺点**



**模块化原理**



**Webpack 原理**



**Webpack 常用插件**



### git



git commit 在断网状态下能提交吗